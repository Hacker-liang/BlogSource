---
title: LeetCode(排序部分)
copyright: true
date: 2018-02-28 11:33:46
tags:
    - LeetCode
category: [LeetCode]
password:
top:
---
**排序算法作为程序员必备的技能我们一起来熟悉一下，想象我们中学体育课排队的时候，明白其中的原理其实很简单**

### 1.冒泡排序

##### 原理说明

先从最简单的冒泡排序开始，一共n个同学排队，体育老师每次从第一个同学开始，拉到第二个同学面前比较，如果你比他高继续和第三个比较，如果你比他矮，那你站在他的位置上，把他拉出来继续和后面的同学比较，一圈下来最后站在老师面前的肯定是最高的，把他放在最后位置。对剩下的n-1个同学继续这么操作直到只剩下一个同学为止。
冒泡排序可以通过是否发生过交互操作来提前判断队列是否已经有序，也算一个优化的点。

![](bubblesort.gif "排序效果图")

##### 代码实现

```python
#python 实现冒泡
def bubbleSort(l):
    for i in range(0, len(l)-1):
        isChanged = False
        for j in range(0, len(l)-1-i):
            if l[j] > l[j+1]:
                value = l[j]
                l[j]=l[j+1]
                l[j+1]=value
                isChanged = True
        if not isChanged:
            print("已经有序了，不需要交换了",i)
            break
    print(l)

bubbleSort([1,2,3,4,6,5,8,0,9,10,11,12])
```
##### 时间复杂度

从代码实现看，需要两次for循环，因此时间复杂度为 **O(n^2)**

### 2.选择排序

##### 原理说明

选择排序和冒泡排序有点类似，区别在于交换次数。体育老师从第一个同学开始，用一个小本记录下该同学身高以及所在位置，依次和剩下的同学比较，如果发现有比本本上的身高低的同学，那么就更新一下本本上的身高以及该同学的位置。一趟下来老师本子上记录的内容是：最低身高以及该身高的同学所在的位置，该同学与第一位同学交互位置。然后从第二名到第n名同学继续进行上述操作。

![](selectsort.gif "排序效果图")

##### 代码实现

```python
#python 选择排序
def selectSort(l):
    for i in range(0, len(l)-1):
        min = l[i]
        index = i
        for j in range(i, len(l)):
            if min > l[j]:
                min = l[j]
                index = j
        value = l[i]
        l[i]=l[index]
        l[index]=value
    print(l)
    
selectSort([1,2,3,4,6,5,8,0,9,10,100,101,3,4,11,12])
```

##### 时间复杂度

从代码实现看，需要两次for循环，因此时间复杂度为 **O(n^2)**， 但因为选择排序每次只进行一次交换，因此大部分情况会高于冒泡排序。

### 3.插入排序

##### 原理说明

插入排序很好懂，第一位同学算作已经排好队了，从第二位同学开始依次向前比较，找到自己合适的位置插入进去。

![](insertsort.gif "排序效果图")

##### 代码实现

```python
#python 插入排序
def insertSort(l):
    for i in range(1, len(l)):
        temp = l[i]
        insertIndex = 0
        for j in range(i, -1, -1):
            if temp<=l[j]:
                insertIndex = j    #更新插入位置
                if j>1 and temp>=l[j-1]:   #如果已经比前一位大了那就不需要继续往前走了
                    break
        del l[i]                     #进行插入
        l.insert(insertIndex,temp)
    print(l)
insertSort([1,2,3,4,6,5,8,0,9,10,100,101,3,4,11,12])
```

##### 时间复杂度

从代码实现看，正常情况下需要两次for循环，因此时间复杂度为 **O(n^2)**，但如果整个数组已经基本有序了第二次for循环的判断次数会大大减少，时间复杂度最好的情况会变成O(n),这也是我们马上要讲到的希尔排序所努力的方向。

### 4.希尔排序

##### 原理说明

希尔排序其实也可以算作是分组插入排序，上面我们讲到如果一个序列基本有序，那插入排序的复杂度可以接近O(n)，希尔排序其实一共分为两部分：1.通过分组进行插入排序来使整个序列基本有序 2.对操作后的序列进行一次插入排序。
希尔排序很关键的一点就是取步长n，也就是每间隔n的元素作为一组

##### 代码实现

```python
#python 希尔排序
def shellSort(l):
    step = int(len(l)/2)
    while step >= 1:
        print("当前增量是：", step)
        for i in range(step, len(l)):
            for j in range(i-step, -step, -step):   # l[j]与l[i]为同一组 元素
                if l[j] > l[j+step]:     #如果发现顺序不对交互当前元素
                    temp = l[j]
                    l[j] = l[j+step]
                    l[j+step] = temp
        step = int(step/2)
    print(l)

shellSort([1,2,3,4,6,5,8,0,9,10,100,101,3,4,11,12])
```

##### 时间复杂度

希尔排序的目标就是通过引入分组这个概念来尽可能花更少的循环来让序列基本有序，因此排序性能是高于直接插入排序的。其时间复杂度为：O(nlog2n)。

### 5.快速排序

##### 原理说明

当时去爱奇艺面试的时候就被问了快速排序，对此印象深刻，快速排序原理很简单，在数组里找一个基准值，小于基准值的放入左边，大于基准值的放入右边，因为左边的数据一定是小于右边的，所以在对左右两边的数据递归的进行上述操作，直到只有一个元素为止。

![](quicksort.gif "排序效果图")

##### 代码实现

```python
#python 快速排序
def quickSort(a, l, r):
    if l < r:
        i = l
        j = r
        x = a[l]    #选取比较基准
        while i < j:
            while(i<j and a[j]>=x):   #从右向左寻找比基准小的元素
                j -= 1
            if i < j:  #说明上面从右往左的寻找找到了比x小的元素
                a[i] = a[j]    #将位置j的元素移动到i上
                i += 1 
            while(i<j and a[i]<x):     #从左向右寻找比x大的元素来填充位置j，因为位置j的元素被填充到位置i上了。
                i += 1
            if i < j:
                a[j] = a[i]
                j -= 1
        a[i] = x   #将基准元素填充到应该填充的位置
        quickSort(a, l, i-1)
        quickSort(a, i+1, r)

s = [1,2,3,4,6,5,8,0,9,10,100,101,3,4,11,12]
quickSort(s, 0, len(s)-1)
print(s)
```

##### 时间复杂度

最坏情况
假设我们每次选择的主元恰好是待排数组中的极值且元素都不重复时，例如最小值：根据切分函数，指针i在遇到第一个元素就停下来，而j却一直向左遍历直到遇到主元才停下来。最终切分的位置变成了left，切分出一个大小为0的数组和一个大小为n - 1的数组，不烦假设每次都出现这种不平等的切分，切分的操作时间复杂度为O(n)，对一个大小为0的数组递归调用排序会直接返回，因此T(0) = O(1)。于是算法的运行时间的递归式可表达为：T(n) = T(0) + T(n - 1) + O(n) = T(n - 1) + O(n)，T(n)的解是O(n^2)。
最好情况
最好的情况是每次切分后的两个数组大小都不大于n / 2时，这时一个的数组的大小为[n / 2 - 1]，另一个为[n / 2]，此时算法运行时间的递归式为：T(n) = 2T(n / 2) + O(n)，T(n)的解是O(nlgn)。